generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

// NextAuth / Auth.js Prisma Adapter
model Account {
  id                String  @id @default(cuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String? @db.Text
  access_token      String? @db.Text
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String? @db.Text
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(cuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
  id                    String       @id @default(cuid())
  name                  String?
  email                 String?      @unique
  emailVerified         DateTime?
  image                 String?
  password              String?      @db.Text
  serpApiKeyEncrypted   String?      @db.Text
  jobCategories         String?      @db.Text // JSON array: ["software-development", "marketing", ...]
  accounts              Account[]
  sessions              Session[]
  applications          Application[]
  jobListings           JobListing[]
}

// Vacantes descubiertas por el cron de scraping (el usuario puede convertirlas en Application)
model JobListing {
  id          String   @id @default(cuid())
  company     String
  role        String
  offerLink   String?  @db.Text
  source      String   // LinkedIn | Indeed | Adzuna | etc.
  category    String?  // slug de categor√≠a: software-development, marketing, design, etc.
  seniority   String?
  modality    String?  // remoto | hibrido | presencial
  description String?  @db.Text
  externalId  String?  // para deduplicar por source + externalId
  userId      String?
  user        User?    @relation(fields: [userId], references: [id], onDelete: SetNull)
  createdAt   DateTime @default(now())

  @@unique([source, externalId, userId])
  @@index([userId])
  @@index([category])
}

model VerificationToken {
  identifier String
  token      String
  expires    DateTime
  @@unique([identifier, token])
}

// ApplicationStatus: Applied | FollowUp | Interview | Rejected | Offer | Ghosted
// Source: LinkedIn | Otra
// Modality: remoto | hibrido | presencial
// ContactChannel: LinkedIn | email
// InteractionType: linkedin | email | call
// TaskType: follow_up | email | call

model Application {
  id                   String   @id @default(cuid())
  userId               String
  user                 User     @relation(fields: [userId], references: [id], onDelete: Cascade)
  company              String
  role                 String
  offerLink            String?
  source               String   @default("LinkedIn") // LinkedIn | Otra
  appliedAt            DateTime @default(now())
  status               String   @default("Applied") // Applied | FollowUp | Interview | Rejected | Offer | Ghosted
  seniority            String?
  modality             String?  // remoto | hibrido | presencial
  expectedSalary       Float?
  requiredStack        String?
  requiresExternalForm Boolean  @default(false)
  externalFormLink     String?
  notes                String?
  checklist            String?  // JSON: portfolio, formulario, referral
  cvVersion            String?  // A/B para analytics
  tags                 String?  // JSON array of strings, e.g. ["frontend","remoto"]
  isFavorite           Boolean  @default(false)
  createdAt            DateTime @default(now())
  updatedAt            DateTime @updatedAt

  contacts     Contact[]
  interactions Interaction[]
  tasks        Task[]
  activities   Activity[]
}

model Activity {
  id             String   @id @default(cuid())
  applicationId  String
  application    Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  type           String   // status_change | note_added | created
  payload        String?  // JSON
  createdAt      DateTime @default(now())
}

model Contact {
  id             String   @id @default(cuid())
  applicationId  String
  application    Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  name           String
  position       String?
  channel        String   @default("LinkedIn") // LinkedIn | email
  link           String?
  notes          String?
}

model Interaction {
  id             String   @id @default(cuid())
  applicationId  String
  application    Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  type           String   // linkedin | email | call
  date           DateTime @default(now())
  responded      Boolean  @default(false)
  textOrSummary  String?
  outcome        String?
}

model Task {
  id             String   @id @default(cuid())
  applicationId  String
  application    Application @relation(fields: [applicationId], references: [id], onDelete: Cascade)
  title          String
  dueAt          DateTime
  completed      Boolean  @default(false)
  type           String   @default("follow_up") // follow_up | email | call
}
